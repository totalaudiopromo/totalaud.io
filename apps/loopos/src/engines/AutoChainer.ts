/**
 * Auto-Chaining Engine
 * AI-powered sequence generation and dependency prediction
 */

import type { DbNode, DbAutoChain } from '@loopos/db'
import { createAutoChain } from '@loopos/db'

export interface ChainSuggestion {
  type: 'predicted-sequence' | 'dependency-chain' | 'campaign-timeline'
  nodes: string[] // Node IDs in sequence order
  confidence: number // 0-100
  reasoning: string
}

export class AutoChainer {
  /**
   * Predict next logical actions based on current nodes
   */
  predictNextActions(nodes: DbNode[]): ChainSuggestion[] {
    const suggestions: ChainSuggestion[] = []

    // Group by type
    const createNodes = nodes.filter((n) => n.type === 'create')
    const promoteNodes = nodes.filter((n) => n.type === 'promote')
    const analyseNodes = nodes.filter((n) => n.type === 'analyse')

    // Pattern: Create → Promote → Analyse
    if (createNodes.length > promoteNodes.length) {
      suggestions.push({
        type: 'predicted-sequence',
        nodes: createNodes.slice(0, 3).map((n) => n.id),
        confidence: 80,
        reasoning: 'You have creation tasks without promotion. Consider adding promotional actions.',
      })
    }

    // Pattern: Missing analysis
    if (promoteNodes.length > 2 && analyseNodes.length === 0) {
      suggestions.push({
        type: 'predicted-sequence',
        nodes: promoteNodes.map((n) => n.id),
        confidence: 75,
        reasoning: 'Multiple promo tasks without analysis. Add metrics review.',
      })
    }

    return suggestions
  }

  /**
   * Auto-generate dependencies based on node relationships
   */
  autoGenerateDependencies(nodes: DbNode[]): Map<string, string[]> {
    const dependencies = new Map<string, string[]>()

    nodes.forEach((node) => {
      const deps: string[] = []

      // Rule: Promote nodes should depend on Create nodes
      if (node.type === 'promote') {
        const createDeps = nodes.filter(
          (n) => n.type === 'create' && n.created_at < node.created_at
        )
        if (createDeps.length > 0) {
          deps.push(createDeps[0].id)
        }
      }

      // Rule: Analyse nodes should depend on Promote nodes
      if (node.type === 'analyse') {
        const promoteDeps = nodes.filter(
          (n) => n.type === 'promote' && n.created_at < node.created_at
        )
        promoteDeps.forEach((dep) => deps.push(dep.id))
      }

      if (deps.length > 0) {
        dependencies.set(node.id, deps)
      }
    })

    return dependencies
  }

  /**
   * Detect redundant nodes (duplicates or unnecessary steps)
   */
  detectRedundantNodes(nodes: DbNode[]): string[] {
    const redundant: string[] = []

    // Find nodes with very similar titles
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const similarity = this.calculateSimilarity(nodes[i].title, nodes[j].title)
        if (similarity > 0.8) {
          redundant.push(nodes[j].id)
        }
      }
    }

    return [...new Set(redundant)]
  }

  /**
   * Generate complete campaign timeline
   */
  async generateCampaignTimeline(
    userId: string,
    campaignType: 'release' | 'promo' | 'growth'
  ): Promise<DbAutoChain> {
    const timeline: DbAutoChain['nodes'] = []

    // Simple templates (in production, use AI generation)
    if (campaignType === 'release') {
      timeline.push(...this.getReleaseTimeline())
    } else if (campaignType === 'promo') {
      timeline.push(...this.getPromoTimeline())
    } else {
      timeline.push(...this.getGrowthTimeline())
    }

    const chain: Omit<DbAutoChain, 'id' | 'created_at' | 'updated_at'> = {
      user_id: userId,
      name: `${campaignType.charAt(0).toUpperCase() + campaignType.slice(1)} Campaign`,
      description: `Auto-generated ${campaignType} timeline`,
      chain_type: 'campaign-timeline',
      nodes: timeline,
      auto_generated: true,
      confidence_score: 85,
      metadata: {
        generated_at: new Date().toISOString(),
        campaign_type: campaignType,
      },
    }

    return createAutoChain(chain)
  }

  // Helper methods

  private calculateSimilarity(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2
    const shorter = str1.length > str2.length ? str2 : str1

    if (longer.length === 0) return 1.0

    const editDistance = this.getEditDistance(longer.toLowerCase(), shorter.toLowerCase())
    return (longer.length - editDistance) / longer.length
  }

  private getEditDistance(s1: string, s2: string): number {
    const costs: number[] = []
    for (let i = 0; i <= s1.length; i++) {
      let lastValue = i
      for (let j = 0; j <= s2.length; j++) {
        if (i === 0) {
          costs[j] = j
        } else if (j > 0) {
          let newValue = costs[j - 1]
          if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1
          }
          costs[j - 1] = lastValue
          lastValue = newValue
        }
      }
      if (i > 0) costs[s2.length] = lastValue
    }
    return costs[s2.length]
  }

  private getReleaseTimeline(): string[] {
    return ['finalize-master', 'create-artwork', 'distribute', 'pitch-playlists', 'social-announce']
  }

  private getPromoTimeline(): string[] {
    return ['create-content', 'influencer-outreach', 'run-ads', 'analyse-performance']
  }

  private getGrowthTimeline(): string[] {
    return ['content-calendar', 'daily-posting', 'community-engagement', 'weekly-review']
  }
}
